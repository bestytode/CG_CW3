// Assessment 3: bezier_curve
// Simple explanation:
// 
// 4 control points. x and y in range(-3, 3), z value fixed 0
// a strip generated by control points, 20 bezier curve points in total
// press 'r' to regenerate, press 'p' to output position infos
// control points in red, bezier curve in orange(controlled by a simple shader)
// 
// Author: Zhenhuan
// Date: 2024/4/17

#include <iostream>
#include <memory>
#include <random>
#include <stdexcept>

#include <GL/gl3w.h>
#include <GLFW/glfw3.h>

#include "camera.h"
#include "geometry_renderers.h"
#include "scene_manager.h"
#include "shader.h"
#include "timer.h"
#include "model.h"

// all static functions & variables, making them only visiable in this translation unit
static glm::vec3 calculateBezierPoint(float t, 
	const std::vector<glm::vec3>& controlPoints);

static void renderScene(Shader& shader, 
	const std::vector<glm::vec3>& controlPoints, 
	const std::vector<glm::vec3>& bezierCurvePoints, 
	std::shared_ptr<Camera> camera, 
	unsigned int curveVAO, unsigned int pointsVAO);

static void regeneratePoints(std::vector<glm::vec3>& controlPoints, 
	std::vector<glm::vec3>& bezierCurvePoints, 
	unsigned int& curveVBO, 
	unsigned int& pointsVBO);

static constexpr int SCR_WIDTH = 1920;  // Screen width
static constexpr int SCR_HEIGHT = 1080; // Screen height
static bool rKeyPressed = false;        // flag to indicate r key pressed

int main()
{
#ifdef DEBUG
	Timer timer;
	timer.start();
#endif 

	// shared pointer holding camera object. plane_near to 0.1f and plane_far to 100.0f by deault.
	// Camera initial position:(0.0f, 0.0f, 6.0f), initial direction: -z
	std::shared_ptr<Camera> camera = std::make_shared<Camera>(0.0f, 0.0f, 6.0f);
	
	// Global scene manager holding window and camera object instance with utility functions.
	// Notice: glfw and glw3 init in SceneManager constructor.
	// -------------------------------------------------------
	SceneManager scene_manager(SCR_WIDTH, SCR_HEIGHT, "bezier_curve", camera);

	// OpenGL global configs
	// ---------------------
	scene_manager.Enable(GL_DEPTH_TEST);

	std::vector<glm::vec3> controlPoints(4);
	std::vector<glm::vec3> bezierCurvePoints;

	// VAOs, VBOs config
	unsigned int curveVBO, curveVAO, pointsVBO, pointsVAO;
	glGenBuffers(1, &curveVBO);
	glGenVertexArrays(1, &curveVAO);
	glGenBuffers(1, &pointsVBO);
	glGenVertexArrays(1, &pointsVAO);

	// Set initial points
	regeneratePoints(controlPoints, bezierCurvePoints, curveVBO, pointsVBO);

	glBindVertexArray(curveVAO);
	glBindBuffer(GL_ARRAY_BUFFER, curveVBO);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	glBindVertexArray(pointsVAO);
	glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	// shader configs
	Shader debug_light_shader("res/shaders/debug_light.vs", "res/shaders/debug_light.fs");

	bool firstTimeOutputPosition = true;

#ifdef DEBUG
	timer.stop();
#endif 

	// Render loop
	while (!glfwWindowShouldClose(scene_manager.GetWindow())) {
		scene_manager.UpdateDeltaTime();
		scene_manager.ProcessInput();

		// Check for 'r' key press
		int state = glfwGetKey(scene_manager.GetWindow(), GLFW_KEY_R);
		if (state == GLFW_PRESS && !rKeyPressed) {
			rKeyPressed = true;  
			firstTimeOutputPosition = true;
		}
		if (state == GLFW_RELEASE && rKeyPressed) {
			rKeyPressed = false; 
			regeneratePoints(controlPoints, bezierCurvePoints, curveVBO, pointsVBO); // Regenerate points and curve only on release
		}

		// Render scene
		renderScene(debug_light_shader, controlPoints, bezierCurvePoints, camera, curveVAO, pointsVAO);

#ifdef _DEBUG
		// output position infos when press p, can only output once with one 'r'
		if (glfwGetKey(scene_manager.GetWindow(), GLFW_KEY_P) == GLFW_PRESS && firstTimeOutputPosition == true) {
			for (size_t i = 0; i < controlPoints.size(); i++) 
				std::cout << "control points from 1 to 3: "<< controlPoints[i].x << " " << controlPoints[i].y << " " << controlPoints[i].z << std::endl;
			firstTimeOutputPosition = false;
		}
#elif _RELEASE
		// doing nothing here for performance optimization
#endif 

		// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
		glfwSwapBuffers(scene_manager.GetWindow());
		glfwPollEvents();
	}

	glfwTerminate();
}

static glm::vec3 calculateBezierPoint(float t, const std::vector<glm::vec3>& controlPoints)
{
	float u = 1 - t;
	float tt = t * t;
	float uu = u * u;
	float uuu = uu * u;
	float ttt = tt * t;

	glm::vec3 p = uuu * controlPoints[0]; // first term
	p += 3 * uu * t * controlPoints[1]; // second term
	p += 3 * u * tt * controlPoints[2]; // third term
	p += ttt * controlPoints[3]; // fourth term

	return p;
}

static void regeneratePoints(std::vector<glm::vec3>& controlPoints, 
	std::vector<glm::vec3>& bezierCurvePoints, 
	unsigned int& curveVBO, 
	unsigned int& pointsVBO) 
{
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_real_distribution<> dis(-3.0, 3.0);

	controlPoints.clear();
	bezierCurvePoints.clear();

	for (int i = 0; i < 4; ++i) 
		controlPoints.emplace_back(dis(gen), dis(gen), 0.0f);

	for (float t = 0; t <= 1.0f; t += 0.05f) 
		bezierCurvePoints.push_back(calculateBezierPoint(t, controlPoints));

	// Update buffer data
	glBindBuffer(GL_ARRAY_BUFFER, curveVBO);
	glBufferData(GL_ARRAY_BUFFER, bezierCurvePoints.size() * sizeof(glm::vec3), &bezierCurvePoints[0], GL_STATIC_DRAW);

	glBindBuffer(GL_ARRAY_BUFFER, pointsVBO);
	glBufferData(GL_ARRAY_BUFFER, controlPoints.size() * sizeof(glm::vec3), &controlPoints[0], GL_STATIC_DRAW);
}

static void renderScene(Shader& shader, 
	const std::vector<glm::vec3>& controlPoints, 
	const std::vector<glm::vec3>& bezierCurvePoints, 
	std::shared_ptr<Camera> camera, 
	unsigned int curveVAO, 
	unsigned int pointsVAO)
{
	// Render
	glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// glsl variables configs
	glm::mat4 projection = glm::perspective(camera->fov, (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
	glm::mat4 view = camera->GetViewMatrix();
	glm::mat4 model = glm::mat4(1.0f);

	shader.Bind();
	shader.SetInt("use_orange_color", 0);
	shader.SetInt("use_red_color", 1);
	shader.SetMat4("projection", projection);
	shader.SetMat4("view", view);
	shader.SetMat4("model", model);

	// rendering control points
	glPointSize(10.0f);
	glBindVertexArray(pointsVAO);
	glDrawArrays(GL_POINTS, 0, 4);
	glBindVertexArray(0);

	// rendering curve
	glPointSize(1.0f);
	shader.SetInt("use_orange_color", 1);
	shader.SetInt("use_red_color", 0);
	glBindVertexArray(curveVAO);
	glDrawArrays(GL_LINE_STRIP, 0, bezierCurvePoints.size());
	glBindVertexArray(0);
}