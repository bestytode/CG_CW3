#pragma once
#ifndef BLOOM_H
#define BLOOM_H

#include "shader.h"
#include "geometry_renderers.h"
#include <GL/gl3w.h>

unsigned int hdrFBO;
unsigned int colorBuffers[2];
unsigned int rboDepth;
GLenum drawBuffers[2] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };
unsigned int pingpongFBO[2];
unsigned int pingpongColorbuffers[2];

//void SetupBloom()
//{
//	glGenFramebuffers(1, &hdrFBO);
//	glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);
//
//	glGenTextures(2, colorBuffers);
//	for (size_t i = 0; i < 2; i++) {
//		glBindTexture(GL_TEXTURE_2D, colorBuffers[i]);
//		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, nullptr);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
//
//		// Attach color buffer to hdrFBO
//		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0);
//	}
//
//	// Create & attach rbo for depth
//
//	glGenRenderbuffers(1, &rboDepth);
//	glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);
//	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, SCR_WIDTH, SCR_HEIGHT);
//	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);
//
//	// Explicitly tell OpenGL render to 2 color buffers
//	// Notice: the location in fragment shader corresponds to the index in this array
//	glDrawBuffers(2, drawBuffers);
//
//	// finally check if framebuffer is complete
//	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
//		std::cout << "Framebuffer not complete!" << std::endl;
//	glBindFramebuffer(GL_FRAMEBUFFER, 0);
//
//	// ping-pong-framebuffer for blurring
//	glGenFramebuffers(2, pingpongFBO);
//	glGenTextures(2, pingpongColorbuffers);
//	for (size_t i = 0; i < 2; i++) {
//		glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]);
//		glBindTexture(GL_TEXTURE_2D, pingpongColorbuffers[i]);
//		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, nullptr);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
//		// clamp to the edge as the blur filter would otherwise sample repeated texture values
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
//		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongColorbuffers[i], 0);
//
//		// also check if framebuffers are complete (no need for depth buffer)
//		if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
//			std::cout << "Framebuffer not complete!" << std::endl;
//	}
//	glBindFramebuffer(GL_FRAMEBUFFER, 0);
//}

void RenderBloomLightSource(Shader& bloomShader, yzh::Sphere& sphere)
{
	bloomShader.Bind();
	sphere.Render();
}

#endif // !BLOOM_H